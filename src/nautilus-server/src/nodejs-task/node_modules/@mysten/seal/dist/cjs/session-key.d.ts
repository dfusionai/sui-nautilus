import type { Signer } from '@mysten/sui/cryptography';
import type { ZkLoginCompatibleClient } from '@mysten/sui/zklogin';
export declare const RequestFormat: import("@mysten/bcs").BcsType<{
    ptb: number[];
    encKey: number[];
    encVerificationKey: number[];
}, {
    ptb: Iterable<number> & {
        length: number;
    };
    encKey: Iterable<number> & {
        length: number;
    };
    encVerificationKey: Iterable<number> & {
        length: number;
    };
}>;
export type Certificate = {
    user: string;
    session_vk: string;
    creation_time: number;
    ttl_min: number;
    signature: string;
};
export type SessionKeyType = {
    address: string;
    packageId: string;
    creationTimeMs: number;
    ttlMin: number;
    personalMessageSignature?: string;
    sessionKey: string;
};
export declare class SessionKey {
    #private;
    constructor({ address, packageId, ttlMin, signer, client, }: {
        address: string;
        packageId: string;
        ttlMin: number;
        signer?: Signer;
        client?: ZkLoginCompatibleClient;
    });
    isExpired(): boolean;
    getAddress(): string;
    getPackageId(): string;
    getPersonalMessage(): Uint8Array;
    setPersonalMessageSignature(personalMessageSignature: string): Promise<void>;
    getCertificate(): Promise<Certificate>;
    createRequestParams(txBytes: Uint8Array): Promise<{
        decryptionKey: Uint8Array;
        requestSignature: string;
    }>;
    /**
     * Export the Session Key object from the instance. Store the object in IndexedDB to persist.
     */
    export(): SessionKeyType;
    /**
     * Restore a SessionKey instance for the given object.
     * @returns A new SessionKey instance with restored state
     */
    static import(data: SessionKeyType, { signer, client }: {
        signer?: Signer;
        client?: ZkLoginCompatibleClient;
    }): Promise<SessionKey>;
}
